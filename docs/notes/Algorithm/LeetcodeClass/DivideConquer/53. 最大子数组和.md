# 53.最大子数组和

对于一个区间 [l,r][l,r][l,r]，我们可以维护四个量：

- lSum 表示 [l,r][l,r][l,r] 内以 lll 为左端点的最大子段和
- rSum 表示 [l,r][l,r][l,r] 内以 rrr 为右端点的最大子段和
- mSum 表示 [l,r][l,r][l,r] 内的最大子段和
- iSum 表示 [l,r][l,r][l,r] 的区间和

```js
var maxSubArray = function (nums) {
  return getInfo(nums, 0, nums.length - 1).mSum;
};

function Status(l, r, m, i) {
  this.lSum = l;
  this.rSum = r;
  this.mSum = m;
  this.iSum = i;
}

function pushUp(l, r) {
  // 子区间的区间和就是isSum的合集
  const iSum = l.iSum + r.iSum;
  // 对于[l,r]的左端点, 有两种情况, 要么等于左子区间的lSum, 要么等于左子区间的iSum + 右子区间的lSum 二者取大
  const lSum = Math.max(l.lSum, l.iSum + r.lSum);
  // 右端点同理
  const rSum = Math.max(r.rSum, r.iSum + l.rSum);
  // 有三种情况, 有可能是左子区间的mSum, 右子区间的mSum 或者跨区间(左子区间的rSum + 右子区间的lSum)
  const mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);
  return new Status(lSum, rSum, mSum, iSum);
}

function getInfo(a, l, r) {
  // 递归的边界, 假如说递归到底, 那么他的左端点, 右端点, 最大子段合, 区间和都是 a[l]
  if (l === r) {
    return new Status(a[l], a[l], a[l], a[l]);
  }
  // 取中间点的索引
  const m = (l + r) >> 1;
  // 递归左右子区间 拿到的是 Status 对象
  const left = getInfo(a, l, m);
  const right = getInfo(a, m + 1, r);
  // 合并两个子区间
  return pushUp(left, right);
}
```
