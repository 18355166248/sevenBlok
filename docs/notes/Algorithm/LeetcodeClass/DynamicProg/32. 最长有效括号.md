# 32. 最长有效括号

### 动态规划

```javascript
var longestValidParentheses = function (s) {
  // 生成dp
  const dp = Array(s.length).fill(0);
  let max = 0;

  // 循环一次 只需要判断右括号即可 所以不用从索引0开始 因为索引0为右括号肯定是不符合的 直接从1开始
  for (let i = 1; i < s.length; i++) {
    if (s[i] === ")") {
      // 判断如果当前是右括号 再判断前一个是左括号还是右括号

      if (s[i - 1] == "(") {
        // 是左括号 那直接完成闭合 直接可以拿前两个的dp下的最长+2 就是当前索引的最长
        dp[i] = (dp[i - 2] || 0) + 2;
      } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == "(") {
        // 是右括号 考虑边界情况 也就是对应的最左边索引存不存在 也就是 i - dp[i]
        // 如果存在改字符 计算他的位置 也就是 i - dp[i-1] - 1 如果是左括号 那满足条件
        // 满足条件后就可以计算当前索引的最长 也就是 前一个的最长 dp[i-1] 加上 当前索引对应的最左边的字符的前一个dp的最长也就是 dp[i- dp[i-1] - 1 - 1] 再加上当前索引2个字符的长度 就是最长
        dp[i] = dp[i - 1] + (dp[i - dp[i - 1] - 2] || 0) + 2;
      }
      // 计算最大值
      max = Math.max(max, dp[i]);
    }
  }
  return max;
};
```

### 计数器的方式

```javascript
// 计数器的方式1
var longestValidParentheses = function (s) {
  // 缓存最大长度
  let max = 0;
  // 一层循环 初始化缓存为0 左括号加1 右括号减一 如果为-1表示不符合规范退出循环
  for (let i = 0; i < s.length; i++) {
    let cache = 0;
    // 判断初始值是否符合规范 不符合直接开始下次循环
    if (s[i].charAt() === "(") cache++;
    else continue;

    // 内循环 从外循环的下一个索引开始
    for (let j = i + 1; j < s.length; j++) {
      // 左括号加1 右括号减一 如果为-1表示不符合规范退出循环
      if (s[j].charAt() === "(") cache++;
      else cache--;

      // cache为0 表示完成闭环 可以判断当前长度是否为最大
      // cache为-1 表示不符合 直接退出循环
      if (cache === 0) max = Math.max(max, j - i + 1);
      if (cache === -1) break;
    }
  }

  return max;
};

// 计数器的方式2
// 时间复杂度 O(n)  空间复杂度 O(1)
var longestValidParentheses = function (s) {
  let max = 0;

  // 初始化计数 左和右
  let left = 0;
  let right = 0;
  // 第一次循环从左往右 左括号left++ 右括号right++ 右括号数量大于左 左右计数清0
  for (let l = 0; l < s.length; l++) {
    if (s[l] === "(") left++;
    else right++;
    if (right > left) {
      left = 0;
      right = 0;
    } else if (left === right) {
      // 左右数量相等 取和后和最大值对比取最大值
      max = Math.max(left + right, max);
    }
  }

  left = 0;
  right = 0;
  // 第二次循环从右往左 左括号left++ 右括号right++ 左括号数量大于右 左右计数清0
  // 左右数量相等 取和后和最大值对比取最大值
  for (let r = s.length - 1; r >= 0; r--) {
    if (s[r] === "(") left++;
    else right++;
    if (right < left) {
      left = 0;
      right = 0;
    } else if (left === right) {
      max = Math.max(left + right, max);
    }
  }
  return max;
};

console.log(longestValidParentheses("(()")); // 2
console.log(longestValidParentheses(")()())")); // 4
console.log(longestValidParentheses("")); // 0
console.log(longestValidParentheses(")(")); // 0
console.log(longestValidParentheses(")()())()()(")); // 4
```

### 栈

```javascript
var longestValidParentheses = function (s) {
  // 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 −1 的元素。
  const stack = [-1];

  let max = 0;
  // 循环字符串长度
  for (let i = 0; i < s.length; i++) {
    if (s[i] === "(") {
      // 如果是左括号 入栈
      stack.unshift(i);
    } else {
      // 如果是右括号 出栈一个左括号
      stack.shift();
      if (stack.length) {
        // 栈不为空 说明还存在左括号或者右括号 计算最长为当前索引减去栈顶索引并比较最大值
        max = Math.max(max, i - stack[0]);
      } else {
        // 栈为空, 将最后一个没有匹配的右括号放入栈中 用于后面计算下一个有效括号的最左侧范围
        stack.unshift(i);
      }
    }
  }
  return max;
};
```
