# 5.最长回文子串

```js
var longestPalindrome = function (s) {
  // 动态规划
  // 边界条件 只有一个字符 直接返回
  // 有两个字符, 相等全部返回 不相等返回第一个字符
  // 生成2个变量, 一个是回文开始索引 一个是回文最大长度
  // 生成一个dp[i][j] 表示i到j是否是回文 初始化全部是false
  // 循环 每个单独的字符也就是 [i,i] 都是回文
  // 两层循环 判断i,j是否是回文 第一次循环初始值从2开始 表示当前的回文长度
  // 第二次循环初始值从索引1开始
  // 如果s[i] === s[j] 则dp[i][j] = dp[i+1][j-1]
  // 边界条件  j - i < 3 的话 默认就是回文
  const length = s.length;
  if (length <= 1) return s;
  if (length === 2) return s[0] === s[1] ? s : s[0];
  let maxLen = 1;
  let start = 0;
  const dp = Array.from({ length }, () => Array(length).fill(false));
  for (let i = 0; i < length; i++) {
    dp[i][i] = true;
  }
  for (let L = 2; L <= length; L++) {
    for (let i = 0; i < length; i++) {
      // 计算右端点
      const j = i + L - 1;
      // 边界条件
      if (j >= length) break;
      if (s[i] !== s[j]) {
        dp[i][j] = false;
      } else {
        // 左右相等且长度小于3 表示中间有且一个一个字 必定是回文串
        if (j - i < 3) {
          dp[i][j] = true;
        } else {
          dp[i][j] = dp[i + 1][j - 1];
        }
      }
      // 当前区间是回文 且长度大于最大历史长度
      if (dp[i][j] && L > maxLen) {
        maxLen = L;
        start = i;
      }
    }
  }
  return s.slice(start, start + maxLen);
};
```
