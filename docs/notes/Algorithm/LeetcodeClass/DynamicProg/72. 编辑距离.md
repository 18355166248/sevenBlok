# 72. 编辑距离

```js
/*
 * @lc app=leetcode.cn id=72 lang=javascript
 *
 * [72] 编辑距离
 */

// @lc code=start
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function (word1, word2) {
  const m = word1.length;
  const n = word2.length;
  // 边界条件 如果有一个为0 则直接返回另外一个长度就是编辑距离
  if (m * n === 0) return m + n;

  // 生成一个二维数组 m+1就是行 n+1就是列 默认都是0
  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
  // 对于边界情况，一个空串和一个非空串的编辑距离为 D[i][0] = i 和 D[0][j] = j，D[i][0] 相当于对 word1 执行 i 次删除操作，D[0][j] 相当于对 word1执行 j 次插入操作。
  for (let i = 0; i < m + 1; i++) {
    dp[i][0] = i;
  }
  for (let j = 0; j < n + 1; j++) {
    dp[0][j] = j;
  }

  // 从索引1开始也就是字符串的开头开始计算
  for (let i = 1; i < m + 1; i++) {
    for (let j = 1; j < n + 1; j++) {
      // 取左侧、上方，然后加1 就是当前位置的编辑距离
      const left = dp[i - 1][j] + 1;
      const down = dp[i][j - 1] + 1;
      // 取左上角的值 有两种情况 假如说当前位置的两个字符相等, 那么不要操作就行, 反之需要多操作一次, 需要 +1
      let left_down = dp[i - 1][j - 1];
      if (word1[i - 1] !== word2[j - 1]) {
        left_down += 1;
      }
      // 基于上面三种情况取最小值
      dp[i][j] = Math.min(left, down, left_down);
    }
  }

  return dp[m][n];
};
// @lc code=end

console.log(minDistance("horse", "ros"));
```
