# 152. 乘积最大子数组

```js
/*
 * @lc app=leetcode.cn id=152 lang=javascript
 *
 * [152] 乘积最大子数组
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function (nums) {
  const len = nums.length;

  // 初始化最大值和最小值集合 存在极端情况
  //   考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个 fmin⁡(i)，它表示以第 i 个元素结尾的乘积最小子数组的乘积
  const minDp = Array(len + 1).fill(0);
  const maxDp = Array(len + 1).fill(0);
  // 初始化索引0的值为1 为了后续循环乘前一个值
  minDp[0] = 1;
  maxDp[0] = 1;

  for (let i = 1; i <= len; i++) {
    // 最大值 = 上一个的最大值*当前值 vs 上一个的最小值*当前值 vs 当前值 三个比谁最大
    maxDp[i] = Math.max(
      maxDp[i - 1] * nums[i - 1],
      Math.max(nums[i - 1], minDp[i - 1] * nums[i - 1])
    );
    // 最小值 = 上一个的最小值*当前值 vs 上一个的最大值*当前值 vs 当前值 三个比谁最小
    minDp[i] = Math.min(
      minDp[i - 1] * nums[i - 1],
      Math.min(nums[i - 1], maxDp[i - 1] * nums[i - 1])
    );
  }
  let max = maxDp[1];
  // 轮训取最大值
  for (let i = 2; i <= len; i++) {
    max = Math.max(max, maxDp[i]);
  }

  return max;
};
// @lc code=end

console.log(maxProduct([2, 3, -2, 4])); // 6
console.log(maxProduct([-2, 0, -1])); // 0
console.log(maxProduct([2, -3, 0, -5, 6, 7])); // 42
console.log(maxProduct([2, -3, 4, -5, 6, 7])); // 5040
console.log(maxProduct([-2])); // -2
```
