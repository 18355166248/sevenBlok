# 673. 最长递增子序列的个数

```js
/*
 * @lc app=leetcode.cn id=673 lang=javascript
 *
 * [673] 最长递增子序列的个数
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @return {number}
 */
var findNumberOfLIS = function (nums) {
  if (nums.length === 1) return 1;

  const m = nums.length;
  // 最大长度
  const dp = Array(m).fill(0);
  // 最大长度的个数
  const maxNumsDp = Array(m).fill(0);
  let maxLength = 0;
  let maxNum = 0;
  for (let i = 0; i < m; i++) {
    dp[i] = 1;
    maxNumsDp[i] = 1;
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        if (dp[j] + 1 > dp[i]) {
          // 当前值大于前面的值的情况 且 前面的值对应的最大长度+1 大于当前值的最大长度的话 表示当前值并不能跟前面的进行合并 而且要取前面的最大长度和最大值 所以重置为前面的值
          dp[i] = dp[j] + 1;
          maxNumsDp[i] = maxNumsDp[j]; // 重置
        } else if (dp[j] + 1 === dp[i]) {
          // 当前值大于前面的值的情况 且 前面的值对应的最大长度+1 等于当前值的最大长度的话 那么表示当前值可以跟前面的进行合并 也就是累加
          maxNumsDp[i] += maxNumsDp[j];
        }
      }
    }
    if (dp[i] > maxLength) {
      // 当前最大长度大于历史最大长度 更新历史最大长度 并更新最大长度个数
      maxLength = dp[i];
      maxNum = maxNumsDp[i]; // 更新到最大值的情况
    } else if (dp[i] === maxLength) {
      // 如果当前最大长度跟历史最大长度相等 累加最大长度个数
      maxNum += maxNumsDp[i]; // 累加
    }
  }
  return maxNum;
};
// @lc code=end

console.log(findNumberOfLIS([1, 3, 5, 4, 7])); // 2
console.log(findNumberOfLIS([2, 2, 2, 2, 2])); // 5
console.log(findNumberOfLIS([3])); // 1
```

- 时间复杂度 O(n log n)
- 空间复杂度 O(n)
