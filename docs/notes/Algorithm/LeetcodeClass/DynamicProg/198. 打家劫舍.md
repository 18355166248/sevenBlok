# 198. 打家劫舍

### 动态规划

```javascript
/*
 * @lc app=leetcode.cn id=198 lang=javascript
 *
 * [198] 打家劫舍
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @return {number}
 */

var rob = function (nums) {
  const len = nums.length;
  // 只有一条数据 直接返回
  if (len === 1) return nums[0];
  // 两条数据 返回最大的
  if (len === 2) return nums[0] > nums[1] ? nums[0] : nums[1];

  // 创建数组 索引0为当前值 索引1为0和1的最大值
  const dp = Array(len).fill(0);
  dp[0] = nums[0];
  dp[1] = nums[0] > nums[1] ? nums[0] : nums[1];

  //  从第三个值开始循环
  for (let i = 2; i < len; i++) {
    // 当前房屋的最大值要么是 前一个房间 要么就是前2个房间+当前房间 取最大值
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
  }
  // console.log(dp);
  return dp[len - 1];
};

// @lc code=end

console.log(rob([1, 2, 3, 1])); // 4
console.log(rob([2, 7, 9, 3, 1])); // 12
console.log(rob([2, 1, 1, 2])); // 4
console.log(rob([1, 3, 1])); // 3
```

- 空间复杂度 O(n)
- 时间复杂度 O(n)

### 滚动数组

```javascript
// 滚动数组
var rob = function (nums) {
  const len = nums.length;
  if (len === 1) return nums[0];
  if (len === 2) return nums[0] > nums[1] ? nums[0] : nums[1];

  // 上面的动态规划其实循环里面只是用到了前一个和前两个的值 所以空间复杂度可以优化成滚动数组 只缓存前一个和前两个值即可
  let first = nums[0];
  let second = nums[0] > nums[1] ? nums[0] : nums[1];

  for (let i = 2; i < len; i++) {
    const secondCache = second;
    second = Math.max(second, first + nums[i]);
    first = secondCache;
  }
  // console.log(dp);
  return second;
};
```

- 空间复杂度 O(1)
- 时间复杂度 O(n)
