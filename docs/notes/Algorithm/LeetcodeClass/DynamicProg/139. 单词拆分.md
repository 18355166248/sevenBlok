# 139. 单词拆分

```js
/*
 * @lc app=leetcode.cn id=139 lang=javascript
 *
 * [139] 单词拆分
 */

// @lc code=start
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
// 递归 穷举
var wordBreak = function (s, wordDict) {
  const set = new Set();
  const len = s.length;
  let has = false;
  dfs(0, 1);
  function dfs(l, r) {
    if (r > len || has) return;
    if (set.has(`${l},${r}`)) {
      dfs(r, r + 1);
      return;
    } else {
      const sliceStr = s.slice(l, r);
      if (wordDict.includes(sliceStr)) {
        if (r === len) {
          has = true;
          return;
        }
        set.add(`${l},${r}`, true);
        dfs(r, r + 1);
      }
    }

    dfs(l, r + 1);
  }
  return has;
};

// @lc code=end

console.log(wordBreak("leetcode", ["leet", "code"])); // true
console.log(wordBreak("applepenapple", ["apple", "pen"])); // true
console.log(wordBreak("catsandog", ["cats", "dog", "sand", "and", "cat"])); // false
console.log(
  wordBreak(
    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab",
    [
      "a",
      "aa",
      "aaa",
      "aaaa",
      "aaaaa",
      "aaaaaa",
      "aaaaaaa",
      "aaaaaaaa",
      "aaaaaaaaa",
      "aaaaaaaaaa",
    ]
  )
); // false
```

- 时间复杂度 O(n2)
- 空间复杂度 O(n\*n)

### 动态规划

```javascript
// 动态规划
var wordBreak = function (s, wordDict) {
  // 数组设置为set 方便查询
  const set = new Set(wordDict);
  const len = s.length;
  // 初始化dp 长度为字符串长度+1 第一个索引默认为true
  const dp = Array(len + 1).fill(false);
  dp[0] = true;
  // 两层循环 判断i是不是符合规则
  // 外循环就是字符串的长度 内循环是从0到外循环的值
  for (let i = 1; i <= len; i++) {
    for (let j = 0; j < i; j++) {
      // 符合标准的前提是 dp[0-j] dp[j-i] 都是符合的那么相合也是符合的
      if (dp[j] && set.has(s.substring(j, i))) {
        dp[i] = true;
        break;
      }
    }
  }
  return dp[len];
};
```

- 时间复杂度 O(n2)
- 空间复杂度 O(n)
