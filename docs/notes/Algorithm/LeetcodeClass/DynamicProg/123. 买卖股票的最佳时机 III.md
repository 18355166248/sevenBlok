# 123. 买卖股票的最佳时机 III

```javascript
/*
 * @lc app=leetcode.cn id=123 lang=javascript
 *
 * [123] 买卖股票的最佳时机 III
 */

// @lc code=start
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
  const len = prices.length;
  if (len === 1) return 0;
  let buy1 = -prices[0]; // 第一天一次买入
  let sell1 = 0; // 第一天一次买入卖出 那就是不赚钱
  let buy2 = -prices[0]; // 第一天二次买入
  let sell2 = 0; // 第一天二次买入卖出 那就是不赚钱
  for (let i = 1; i < len; i++) {
    // 第一次买入: 不做任何操作那就用历史的buy1, 买入的话 那就是 -prices[i]
    buy1 = Math.max(buy1, -prices[i]);
    // 第一次买入卖出: 不做任何操作那就用历史的sell1, 卖出的话基于第一次买入buy1+ 买入当前价格prices[i]
    sell1 = Math.max(sell1, buy1 + prices[i]);
    // 第二次买入: 不做任何操作那就用历史的buy2, 买入的话基于第一次买入卖出的sell1-卖出当前价格prices[i]
    buy2 = Math.max(buy2, sell1 - prices[i]);
    // 第二次卖出: 不做任何操作那就用历史的sell2, 卖出的话基于第二次买入的buy2+卖出当前价格prices[i]
    sell2 = Math.max(sell2, buy2 + prices[i]);
  }
  // 最后需要再 0 和 sell1 , sell2中取最大值
  // sell1和sell2默认是0, 且sell2是包含sell1的, 因为存在当前买入卖出又买入卖出的情况 所以最大值取sell2即可
  return sell2;
};
// @lc code=end

console.log(maxProfit([3, 3, 5, 0, 0, 3, 1, 4])); // 6
console.log(maxProfit([1, 2, 3, 4, 5])); // 4
console.log(maxProfit([7, 6, 4, 3, 1])); // 0
console.log(maxProfit([1])); // 0
```

- 时间复杂度 O(n)
- 空间复杂度 O(1)
