# 10. 正则表达式匹配

### 动态规划

```js
/*
 * @lc app=leetcode.cn id=10 lang=javascript
 *
 * [10] 正则表达式匹配
 */

// @lc code=start
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function (s, p) {
  const m = s.length;
  const n = p.length;

  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));
  // 边界条件 两个空字符串是可以匹配的
  dp[0][0] = true;
  for (let i = 0; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (p[j - 1] === "*") {
        // 如果当前是* 假如说匹配0个 那[i][j]就等于前一个匹配结果[i][j-2]
        dp[i][j] = dp[i][j - 2];
        // 如果匹配多个
        if (matches(s, p, i, j - 1)) {
          dp[i][j] = dp[i][j] || dp[i - 1][j];
        }
      } else {
        // 如果 p 的第 j 个字符不是星号 判断当前p是否是.或者当前p和s是否相等 如果满足 那么是否匹配就基于前一个字符[i-1][j-1]
        if (matches(s, p, i, j)) {
          dp[i][j] = dp[i - 1][j - 1];
        }
      }
    }
  }
  return dp[m][n];
};
function matches(s, p, i, j) {
  if (i === 0) return false;
  if (p.charAt(j - 1) === ".") return true;
  return s.charAt(i - 1) === p.charAt(j - 1);
}
// @lc code=end

// console.log(isMatch("aa", "a")); // false
// console.log(isMatch("aa", "a*")); // true
console.log(isMatch("ab", ".*")); // true
```

### 升级版 需要匹配问号?

#### 问题:

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '\*' 的正则表达式匹配。

'.' 匹配任意单个字符
'\*' 匹配零个或多个前面的那一个元素
'?'匹配零个或一个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

示例 1：

输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
示例 2:

输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3：

输入：s = "ab", p = "._"
输出：true
解释："._" 表示可匹配零个或多个（'\*'）任意字符（'.'）。

输入：s = "1123", p = "1?23"
输出：true

输入：s = "123", p = "1?23"
输出：true

请写出js写法

```javascript
function isMatch(s, p) {
  const m = s.length;
  const n = p.length;

  // dp[i][j] 表示 s 的前 i 个字符与 p 的前 j 个字符是否匹配
  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));
  dp[0][0] = true;

  // 初始化dp表格，对于可以由 * 或 ? 组成的空模式进行初始化
  for (let j = 1; j <= n; j++) {
    if (p[j - 1] == "*") {
      // 如果当前模式字符是 *，则其可以匹配零个前面的字符，所以取决于去掉两个字符前是否匹配。
      dp[0][j] = dp[0][j - 2];
    } else if (p[j - 1] == "?") {
      // 如果当前模式字符是 ?，则其也能匹配空字符串，所以继承前一个状态。
      dp[0][j] = dp[0][j - 1];
    }
  }

  // 根据不同的字符类型（普通字符、.、*、?），更新 dp 表格。
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (p[j - 1] == "." || p[j - 1] == s[i - 1]) {
        // 如果当前字符匹配或是通配符 .，则继承对角线的状态。
        dp[i][j] = dp[i - 1][j - 1];
      } else if (p[j - 1] == "*") {
        // 如果当前字符是 *，则有两种情况，如果不匹配任何字符，继承两列前状态；如果匹配前一个字符，则继承上一行状态。
        dp[i][j] =
          dp[i][j - 2] ||
          (dp[i - 1][j] && (p[j - 2] == "." || p[j - 2] == s[i - 1]));
      } else if (p[j - 1] == "?") {
        // 如果当前字符是 ?，则有两种情况，一种是匹配前一个字符，另一种是不匹配前一个字符，所以继承前一个状态或者对角线的状态。
        dp[i][j] = dp[i][j - 1] || dp[i - 1][j - 1];
      }
    }
  }
  // 检查 dp[m][n] 是否为 true，表示整个字符串 s 和 模式 p 是否匹配。
  return dp[m][n];
}

// 示例用法
console.log(isMatch("aa", "a")); // 输出: false
console.log(isMatch("aa", "a*")); // 输出: true
console.log(isMatch("ab", ".*")); // 输出: true
console.log(isMatch("abcdef", ".*")); // 输出: true
console.log(isMatch("1123", "1?23")); // 输出: true
console.log(isMatch("123", "1?23")); // 输出: true
```
