# 494. 目标和

```js
/*
 * @lc app=leetcode.cn id=494 lang=javascript
 *
 * [494] 目标和
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findTargetSumWays = function (nums, target) {
  const n = nums.length;

  const sum = nums.reduce((t, n) => t + n, 0);
  // 如果target + sum不是一个偶数 表示P不是整数 那就表示nums里面有小数 但是这是不可能的事 所以这种情况是不存在的 之间返回0 表示没有匹配个数
  // 或者总和小于目标值的绝对值 表示也不存在 直接返回0
  if ((target + sum) % 2 > 0 || sum < Math.abs(target)) {
    return 0;
  }

  // P表示所有+的和
  // H表示所有-的和
  // P - H = target
  // P + H = sum(nums)
  // 2P = target + sum(nums)
  // P = (target + sum(nums)) / 2
  // 所有该问题变成了求合成 P的子集个数问题
  const P = (target + sum) / 2;

  // 生成P+1的dp集合 因为目前的问题已经拆解成球P的子集个数
  const dp = Array(P + 1).fill(0);
  // 合成0需要1次 表示和为 0 的子集只有一个，就是空集。
  dp[0] = 1;

  for (let i = 0; i < n; i++) {
    // 从大到小计算 防止重复累加当前值造成结果错误
    // 每次循环的开始值为P表示+情况的总和
    // 结束值为当前是nums[i] 每个nums[i] 只应该出现一次 不能重复 所有需要递减计算
    // 如果递增的话 从nums[i]开始 首先会先计算dp[小一点的值]
    for (let j = P; j >= nums[i]; j--) {
      dp[j] += dp[j - nums[i]];
    }
  }
  // console.log(dp);
  return dp[P];
};
// @lc code=end

console.log(findTargetSumWays([1, 1, 1, 1, 1], 3)); //5
console.log(findTargetSumWays([1, 1, 1, 1], 3)); // 0
console.log(findTargetSumWays([1], 1)); //1
console.log(findTargetSumWays([1000], 1000)); //1
```

# 时间复杂度 O(n\*p)

p表示+集合的值

# 空间复杂度 O(p)

### 回溯

```javascript
var findTargetSumWays = function (nums, target) {
  let count = 0;
  function breakNum(nums, target, index, sum) {
    if (index === nums.length) {
      if (sum === target) {
        count++;
      }
      return;
    }
    breakNum(nums, target, index + 1, sum + nums[index]);
    breakNum(nums, target, index + 1, sum - nums[index]);
  }

  breakNum(nums, target, 0, 0);
  return count;
};
```
